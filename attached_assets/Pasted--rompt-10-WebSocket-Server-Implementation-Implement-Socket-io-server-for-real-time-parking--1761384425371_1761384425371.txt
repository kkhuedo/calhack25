**rompt 10: WebSocket Server Implementation**

```
Implement Socket.io server for real-time parking updates:

FEATURES:
1. Client connects and joins room based on geographic area (e.g., 'zone_37.8_-122.4')
2. When spot reported, broadcast to all clients in same zone
3. Handle disconnect/reconnect gracefully
4. Room management: clients auto-join/leave rooms as they move

EVENTS:
- Client -> Server: 'subscribe:zone', 'report:spot'
- Server -> Client: 'spot:new', 'spot:update', 'spot:removed'

INTEGRATION:
- Works alongside Express server
- Shares authentication middleware if needed

Include connection logging and error handling

```

**Prompt 11: PostgreSQL Schema with PostGIS**

```
Design PostgreSQL database schema for parking spot tracking with geospatial support:

TABLES:
1. spots
   - id (UUID primary key)
   - location (GEOGRAPHY point)
   - status (enum: available, occupied, unknown)
   - confidence_score (integer 0-100)
   - last_updated (timestamp)
   - created_at (timestamp)
   - reported_by (UUID foreign key to users)

2. reports (audit log)
   - id (UUID primary key)
   - spot_id (foreign key)
   - event_type (enum: parked, left, correction)
   - timestamp (timestamp)
   - user_id (UUID)
   - location (GEOGRAPHY point)

INDEXES:
- Geospatial index on spots.location for radius queries
- B-tree index on spots.last_updated for time-based queries

EXTENSIONS:
- PostGIS for geography support

Include sample queries:
- Find spots within radius
- Get spots updated in last 30 minutes
- Calculate confidence decay

```

**Prompt 12: Confidence Scoring Algorithm**

```
Implement confidence scoring algorithm for parking spot availability:

INPUTS:
- lastUpdated: timestamp of last report
- reportType: 'parked' | 'left'
- correctionCount: number of users who reported inaccuracy
- historicalPattern: average occupancy for this location/time (0-1)

LOGIC:
1. Base confidence: 95 for fresh reports
2. Time decay:
   - 0-30 min: no decay
   - 30-60 min: -20 points
   - 60-90 min: -25 points
   - 90+ min: -30 points
3. Correction penalty: -15 points per correction
4. Historical boost/penalty: Â±10 points if pattern strong
5. Clamp result between 10-100

OUTPUT: Integer confidence score

Include unit tests for edge cases and explain the reasoning for each decay rate

```

---

## IV. ALGORITHM & DATA SCIENCE PROMPTS

**Prompt 13: Geospatial Radius Query**

```
Write SQL query using PostGIS to find parking spots within a given radius:

REQUIREMENTS:
- Find all spots within X meters of a point (lat, lon)
- Calculate distance from query point to each spot
- Return results sorted by distance
- Include confidence score and last_updated
- Limit to 50 results
- Only include spots updated in last 2 hours

PERFORMANCE:
- Use spatial index (GIST)
- Explain query plan optimization

Provide both the SQL query and a JavaScript function that safely parameterizes it

```

**Prompt 14: Historical Pattern Analysis**

```
Design algorithm to learn historical parking patterns:

GOAL: Predict typical occupancy for any location at any time

DATA STRUCTURE:
Store aggregated data as:
{
  location: geohash or grid cell,
  hour: 0-23,
  dayOfWeek: 0-6,
  avgOccupancy: 0-1,
  sampleSize: integer,
  lastUpdated: timestamp
}

ALGORITHM:
1. Group reports by location (100m grid) + hour + day
2. Calculate rolling average occupancy
3. Weight recent data more heavily (exponential moving average)
4. Minimum sample size before trusting pattern (e.g., 20 reports)

QUERY:
Given current location and time, return expected occupancy

Provide pseudocode and discuss trade-offs between accuracy and storage

```

**Prompt 15: Zone Aggregation Logic**

```
Implement zone-level aggregation for parking availability:

INPUT: Array of individual spots with confidence scores
OUTPUT: Zone-level summary "3-5 spots likely available in this area"

ALGORITHM:
1. Group spots by 100m radius circles (use H3 geohashing)
2. For each zone, calculate:
   - High confidence spots (85-100%): count as 1.0 available
   - Medium confidence (50-84%): count as 0.5 available
   - Low confidence (<50%): count as 0.2 available
3. Sum weighted availabilities
4. Express as range: floor(sum) to ceil(sum)

EDGE CASES:
- Zone with no reports: show "Unknown"
- Zone with only low confidence: "Possibly 1-2 spots"
- Zone with high confidence: "Definitely 3+ spots"

Provide implementation in JavaScript/TypeScript

```

**Prompt 16: Anomaly Detection**
# ParkSpot - Prompt Engineering Guide for Hackathon

**Purpose:** Ready-to-use prompts for AI tools (ChatGPT, Claude, GitHub Copilot, Cursor, etc.) to accelerate development

---

## I. DESIGN & UX PROMPTS

### For UI/UX Design (ChatGPT, Claude, Midjourney)

**Prompt 1: App Interface Design**

```
I'm designing a mobile parking availability app called ParkSpot. Design a clean, modern mobile interface with these requirements:

SCREENS NEEDED:
1. Map view showing parking spots with color-coded confidence levels (green=high, yellow=medium, red=low)
2. Floating action button for "Report Parking"
3. Bottom sheet showing spot details when user taps marker
4. Report modal with two large buttons: "I Parked Here" and "I'm Leaving"

DESIGN STYLE:
- Minimalist, Uber/Lyft-like aesthetic
- Primary color: Blue (#2196F3)
- Confidence colors: Green (#4CAF50), Yellow (#FFC107), Red (#F44336)
- Sans-serif font (Roboto or SF Pro)
- High contrast for outdoor visibility

OUTPUT:
Provide Figma-style component descriptions, color palette hex codes, and spacing guidelines (in 8px increments)

```

**Prompt 2: Icon Design**

```
Design custom map marker icons for a parking app with these states:
1. Available spot (high confidence) - green pin
2. Available spot (medium confidence) - yellow pin
3. Occupied spot - red pin
4. Unknown/stale spot - gray pin with question mark
5. User location - blue dot with pulsing ring

Style: Minimalist, 32x32px, flat design, clearly distinguishable at small sizes
Provide SVG code or detailed description for implementation

```

**Prompt 3: User Flow Diagram**

```
Create a detailed user flow diagram for parking spot reporting:

SCENARIO: User parks car and reports it
START: User opens app
STEPS:
1. App loads map with current location
2. User finds parking spot
3. User taps floating "Report" button
4. Modal appears with two options
5. User taps "I Parked Here"
6. Confirmation animation appears
7. Spot appears on map for all users
8. User receives +10 points notification

Include decision points, error states (no GPS, no network), and alternative paths

```

**Prompt 4: Color Accessibility Check**

```
Evaluate this color scheme for accessibility (WCAG 2.1 AA compliance):
- Background: White (#FFFFFF)
- Primary: Blue (#2196F3)
- Success/Available: Green (#4CAF50)
- Warning/Medium: Yellow (#FFC107)
- Error/Occupied: Red (#F44336)
- Text: Dark Gray (#212121)

Check contrast ratios and suggest improvements for colorblind users (deuteranopia, protanopia)

```

---

## II. FRONTEND DEVELOPMENT PROMPTS

### For React Native Development

**Prompt 5: Map Component Setup**

```
Create a React Native map component for a parking app with these features:

REQUIREMENTS:
- Use react-native-maps library
- Center on user's current location with permission handling
- Display custom markers at parking spot coordinates
- Markers change color based on confidence score (0-100):
  * 85-100: green
  * 50-84: yellow
  * 0-49: red
- Tappable markers that show callout with spot details
- "Center on Me" button
- Handle location permission denial gracefully

PROPS:
- spots: array of {id, latitude, longitude, confidence, status}
- onMarkerPress: callback function
- userLocation: {latitude, longitude}

Include error boundaries and loading states. Use TypeScript if possible.

```

**Prompt 6: Real-Time WebSocket Integration**

```
Implement WebSocket client in React Native that:

FEATURES:
1. Connects to server on app mount
2. Subscribes to parking updates within user's viewport (radius)
3. Listens for events: 'spot:new', 'spot:update', 'spot:removed'
4. Updates local state when events received
5. Handles reconnection on network failure
6. Unsubscribes when user moves out of area

LIBRARIES: socket.io-client
STATE MANAGEMENT: React hooks (useState, useEffect)

Include connection status indicator and reconnection logic with exponential backoff

```

**Prompt 7: Report Parking Modal**

```
Create a React Native modal component for parking reporting:

DESIGN:
- Slides up from bottom (react-native-modal or built-in)
- Two large, touch-friendly buttons (minimum 64px height)
- Button 1: "I Parked Here" (green background)
- Button 2: "I'm Leaving" (blue background)
- Each button has icon + text
- Haptic feedback on press
- Confirmation animation (checkmark) after selection
- Auto-dismiss after 2 seconds

PROPS:
- visible: boolean
- onReportParked: callback
- onReportLeaving: callback
- onClose: callback

Include loading state during API call and error handling

```

**Prompt 8: Geolocation Hook**

```
Create a custom React Native hook called useUserLocation that:

FUNCTIONALITY:
- Requests location permissions on mount
- Gets user's current position
- Watches position changes (updates every 10 seconds)
- Returns: {location, error, loading, requestPermission}
- Cleans up watchers on unmount

LIBRARIES: @react-native-community/geolocation or expo-location
ERROR HANDLING: Permission denied, timeout, position unavailable

Include TypeScript types and permission request UI guidance

```

---

## III. BACKEND DEVELOPMENT PROMPTS

### For Node.js/Express Development

**Prompt 9: Express API Setup**

```
Create a Node.js Express server with these endpoints for a parking app:

ENDPOINTS:
1. POST /api/spots/report
   Body: {latitude, longitude, status: 'parked'|'left', userId}
   Response: {spotId, confidence, message}

2. GET /api/spots/nearby
   Query: {latitude, longitude, radius} (radius in meters)
   Response: {spots: [{id, location, confidence, status, lastUpdated}]}

3. POST /api/spots/:id/correct
   Body: {correction: 'not_available'|'different_location'}
   Response: {updated: boolean}

FEATURES:
- Input validation with express-validator
- Error handling middleware
- CORS enabled
- JSON logging with morgan
- Rate limiting (express-rate-limit)

Include TypeScript types and example test cases with supertest

```

**Prompt 10: WebSocket Server Implementation**

```
Implement Socket.io server for real-time parking updates:

FEATURES:
1. Client connects and joins room based on geographic area (e.g., 'zone_37.8_-122.4')
2. When spot reported, broadcast to all clients in same zone
3. Handle disconnect/reconnect gracefully
4. Room management: clients auto-join/leave rooms as they move

EVENTS:
- Client -> Server: 'subscribe:zone', 'report:spot'
- Server -> Client: 'spot:new', 'spot:update', 'spot:removed'

INTEGRATION:
- Works alongside Express server
- Shares authentication middleware if needed

Include connection logging and error handling

```

**Prompt 11: PostgreSQL Schema with PostGIS**

```
Design PostgreSQL database schema for parking spot tracking with geospatial support:

TABLES:
1. spots
   - id (UUID primary key)
   - location (GEOGRAPHY point)
   - status (enum: available, occupied, unknown)
   - confidence_score (integer 0-100)
   - last_updated (timestamp)
   - created_at (timestamp)
   - reported_by (UUID foreign key to users)

2. reports (audit log)
   - id (UUID primary key)
   - spot_id (foreign key)
   - event_type (enum: parked, left, correction)
   - timestamp (timestamp)
   - user_id (UUID)
   - location (GEOGRAPHY point)

INDEXES:
- Geospatial index on spots.location for radius queries
- B-tree index on spots.last_updated for time-based queries

EXTENSIONS:
- PostGIS for geography support

Include sample queries:
- Find spots within radius
- Get spots updated in last 30 minutes
- Calculate confidence decay

```

**Prompt 12: Confidence Scoring Algorithm**

```
Implement confidence scoring algorithm for parking spot availability:

INPUTS:
- lastUpdated: timestamp of last report
- reportType: 'parked' | 'left'
- correctionCount: number of users who reported inaccuracy
- historicalPattern: average occupancy for this location/time (0-1)

LOGIC:
1. Base confidence: 95 for fresh reports
2. Time decay:
   - 0-30 min: no decay
   - 30-60 min: -20 points
   - 60-90 min: -25 points
   - 90+ min: -30 points
3. Correction penalty: -15 points per correction
4. Historical boost/penalty: Â±10 points if pattern strong
5. Clamp result between 10-100

OUTPUT: Integer confidence score

Include unit tests for edge cases and explain the reasoning for each decay rate

```

---

## IV. ALGORITHM & DATA SCIENCE PROMPTS

**Prompt 13: Geospatial Radius Query**

```
Write SQL query using PostGIS to find parking spots within a given radius:

REQUIREMENTS:
- Find all spots within X meters of a point (lat, lon)
- Calculate distance from query point to each spot
- Return results sorted by distance
- Include confidence score and last_updated
- Limit to 50 results
- Only include spots updated in last 2 hours

PERFORMANCE:
- Use spatial index (GIST)
- Explain query plan optimization

Provide both the SQL query and a JavaScript function that safely parameterizes it

```

**Prompt 14: Historical Pattern Analysis**

```
Design algorithm to learn historical parking patterns:

GOAL: Predict typical occupancy for any location at any time

DATA STRUCTURE:
Store aggregated data as:
{
  location: geohash or grid cell,
  hour: 0-23,
  dayOfWeek: 0-6,
  avgOccupancy: 0-1,
  sampleSize: integer,
  lastUpdated: timestamp
}

ALGORITHM:
1. Group reports by location (100m grid) + hour + day
2. Calculate rolling average occupancy
3. Weight recent data more heavily (exponential moving average)
4. Minimum sample size before trusting pattern (e.g., 20 reports)

QUERY:
Given current location and time, return expected occupancy

Provide pseudocode and discuss trade-offs between accuracy and storage

```

**Prompt 15: Zone Aggregation Logic**

```
Implement zone-level aggregation for parking availability:

INPUT: Array of individual spots with confidence scores
OUTPUT: Zone-level summary "3-5 spots likely available in this area"

ALGORITHM:
1. Group spots by 100m radius circles (use H3 geohashing)
2. For each zone, calculate:
   - High confidence spots (85-100%): count as 1.0 available
   - Medium confidence (50-84%): count as 0.5 available
   - Low confidence (<50%): count as 0.2 available
3. Sum weighted availabilities
4. Express as range: floor(sum) to ceil(sum)

EDGE CASES:
- Zone with no reports: show "Unknown"
- Zone with only low confidence: "Possibly 1-2 spots"
- Zone with high confidence: "Definitely 3+ spots"

Provide implementation in JavaScript/TypeScript

```

**Prompt 16: Anomaly Detection**

```
Design anomaly detection system for parking patterns:

PURPOSE: Identify unusual parking situations worth alerting users

ANOMALIES TO DETECT:
1. Unexpected availability: "Usually 90% full, today only 40%"
2. Sudden occupancy surge: "20 spots filled in 10 minutes"
3. Conflicting reports: Multiple users report different statuses
4. Suspicious patterns: Same user reports parking/leaving rapidly

APPROACH:
- Use rolling averages and standard deviations
- Z-score for statistical significance
- Threshold for alerting (e.g., 2 standard deviations)

OUTPUT:
- Alert type and severity
- Suggested user notification
- Data for dashboard

Provide statistical model and implementation pseudocode

```

---

## V. TESTING PROMPTS

**Prompt 17: Unit Test Suite**

```
Generate comprehensive unit tests for confidence scoring function:

FUNCTION TO TEST:
calculateConfidence(spot: {lastUpdated: Date, correctionCount: number, historicalPattern?: number})

TEST CASES:
1. Fresh report (< 5 min old) should return 95
2. 30-minute old report should return ~75
3. 60-minute old report should return ~50
4. Report with 2 corrections should reduce confidence by 30
5. Historical pattern boost/penalty
6. Edge case: null/undefined inputs
7. Edge case: future timestamp
8. Edge case: very old timestamp (>24 hours)

FRAMEWORK: Jest or Mocha
Include setup, teardown, and mock data generators

```

**Prompt 18: Integration Test Scenarios**

```
Write integration test for full parking report flow:

SCENARIO: User reports parking, other user sees update

STEPS:
1. User A authenticates
2. User A posts to /api/spots/report with location
3. Verify: Database has new spot record
4. Verify: Response includes spotId and confidence
5. User B connects via WebSocket in same zone
6. Verify: User B receives 'spot:new' event within 5 seconds
7. User B queries /api/spots/nearby
8. Verify: New spot appears in results
9. Wait 30 minutes (mock time)
10. Query spot again
11. Verify: Confidence decreased

TOOLS: Supertest, Socket.io-client, PostgreSQL test database
Provide complete test code with setup/teardown

```

**Prompt 19: Load Testing Script**

```
Create load test script for parking app backend:

SCENARIOS:
1. 100 concurrent users querying nearby spots
2. 50 users reporting parking simultaneously
3. 200 WebSocket connections receiving updates
4. Mixed load: 60% queries, 30% reports, 10% corrections

METRICS TO COLLECT:
- Average response time
- 95th percentile latency
- Error rate
- Database connection pool usage
- WebSocket message delivery time

TOOLS: Artillery, k6, or custom Node.js script
TARGET: < 200ms response time for 95% of requests
Include ramp-up period and sustained load period

```

---

## VI. DEPLOYMENT & DEVOPS PROMPTS

**Prompt 20: Docker Configuration**

```
Create Docker setup for parking app with these services:

SERVICES:
1. Frontend: React Native web build (optional for web version)
2. Backend: Node.js Express + Socket.io
3. Database: PostgreSQL 15 with PostGIS
4. Redis: For caching and session management (optional)

REQUIREMENTS:
- docker-compose.yml for local development
- Separate Dockerfile for each service
- Environment variable management
- Volume mounts for database persistence
- Network configuration for service communication
- Health checks for each service

Include README with setup instructions and common commands

```

**Prompt 21: Railway Deployment Config**

```
Provide deployment configuration for Railway.app:

REQUIREMENTS:
- Node.js backend deployment
- PostgreSQL with PostGIS plugin
- Environment variables setup (DATABASE_URL, PORT, etc.)
- Build command and start command
- Health check endpoint configuration
- Auto-deploy on git push to main branch

Include:
- railway.json configuration
- Environment variable list with descriptions
- Database migration strategy
- Rollback procedure

Provide step-by-step deployment guide

```

**Prompt 22: CI/CD Pipeline**

```
Design GitHub Actions workflow for continuous integration:

TRIGGERS:
- On push to main branch
- On pull request

JOBS:
1. Test:
   - Run ESLint
   - Run unit tests (Jest)
   - Run integration tests
   - Check code coverage (minimum 70%)

2. Build:
   - Build React Native app (if changed)
   - Build backend (TypeScript compilation)
   - Docker image build (optional)

3. Deploy (main branch only):
   - Deploy to Railway/Render
   - Run database migrations
   - Smoke test deployed app

NOTIFICATIONS:
- Slack or Discord on failure
- GitHub commit status checks

Provide complete .github/workflows/ci.yml file

```

---

## VII. DOCUMENTATION PROMPTS

**Prompt 23: API Documentation**

```
Generate OpenAPI (Swagger) documentation for parking app API:

ENDPOINTS TO DOCUMENT:
1. POST /api/spots/report
2. GET /api/spots/nearby
3. POST /api/spots/:id/correct
4. GET /api/spots/:id

FOR EACH ENDPOINT:
- Description and purpose
- Request parameters (path, query, body)
- Request examples
- Response schema
- Response examples (success and error cases)
- Authentication requirements
- Rate limiting
- Error codes and meanings

OUTPUT: OpenAPI 3.0 YAML specification
Include example values and data types

```

**Prompt 24: README Generator**

```
Create comprehensive README.md for ParkSpot GitHub repository:

SECTIONS:
1. Banner/Logo and tagline
2. Demo (GIF or video link)
3. Problem statement
4. Solution overview
5. Key features (bullet points)
6. Tech stack
7. Architecture diagram (describe for Mermaid.js)
8. Installation instructions (local development)
9. Environment variables
10. API documentation link
11. Contributing guidelines
12. License (MIT)
13. Team/Authors
14. Acknowledgments

TONE: Professional, concise, developer-focused
Include badges for build status, coverage, license
Format for excellent first impression to judges/employers

```

**Prompt 25: Architecture Diagram (Mermaid)**

```
Create Mermaid.js diagram showing ParkSpot system architecture:

COMPONENTS:
1. Mobile App (React Native)
2. WebSocket Server (Socket.io)
3. REST API (Express)
4. Background Jobs (Node-cron)
5. Database (PostgreSQL + PostGIS)
6. External APIs (City Parking, Google Maps)

FLOWS TO SHOW:
- User reports parking -> API -> Database -> WebSocket -> Other users
- Periodic confidence decay job
- User queries nearby spots -> API -> Database (geospatial query)
- External data integration

Use Mermaid flowchart or sequence diagram syntax
Include data flow direction and main technologies

```

---

## VIII. PRESENTATION PROMPTS

**Prompt 26: Pitch Deck Content**

```
Generate slide content for 5-minute hackathon pitch:

SLIDE 1 - TITLE:
- Hook: Attention-grabbing statistic about parking
- Project name and tagline
- Team names

SLIDE 2 - PROBLEM:
- 3 bullet points about parking pain points with data
- Visual: frustrated driver or traffic chart
- Existing solution gaps

SLIDE 3 - SOLUTION:
- One-sentence description of ParkSpot
- How it works (3 steps with icons)
- Key innovation: confidence-based predictions

SLIDE 4 - DEMO:
- Screenshots or demo video
- Before/after comparison
- Key features highlighted

SLIDE 5 - TECHNICAL:
- High-level architecture
- Technologies used
- Innovation highlights

SLIDE 6 - MARKET:
- Target users
- Go-to-market strategy
- Business model

SLIDE 7 - NEXT STEPS:
- Roadmap (3-6 months)
- Partnerships
- Call to action

For each slide, provide:
- Main message (one sentence)
- Supporting points (2-3 bullets)
- Visual suggestions
- Speaker notes (30-45 seconds of content)

```

**Prompt 27: Demo Script Writer**

```
Write detailed demo script for 2-minute live demonstration:

SETUP:
- 2 phones/devices visible to audience
- Backend confirmed running
- Test data loaded

SCRIPT FORMAT:
[TIME] [WHO] [ACTION] [WHAT TO SAY]

Example:
[0:00] Presenter: Introduce demo: "Let me show you ParkSpot working in real-time..."
[0:15] Device A: Open app: "User A opens the app and sees their location with existing spots..."
[0:30] Device A: Tap report: "They find parking and tap 'I Parked Here'..."
[0:45] Device B: Auto-update: "Notice Device B, across the room, receives the update instantly..."
[1:00] Screen: Show backend: "Behind the scenes, our confidence algorithm is working..."
[1:30] Device A: Show decay: "Over time, confidence decreases as the report ages..."
[2:00] Presenter: Conclude: "That's ParkSpot - real-time, honest, and scalable."

Include:
- Contingency plans for each step if tech fails
- Backup talking points
- Energy/enthusiasm cues

```

**Prompt 28: Judge Q&A Preparation**

```
Generate comprehensive Q&A prep for hackathon judges:

ANTICIPATED QUESTIONS (with answers):

TECHNICAL:
1. "How do you handle GPS inaccuracy?"
2. "What if users don't report when they leave?"
3. "How does this scale to millions of users?"
4. "What about privacy concerns?"
5. "Why WebSockets instead of polling?"

BUSINESS:
6. "How do you solve cold-start problem (no users initially)?"
7. "What's your monetization strategy?"
8. "Who are your competitors?"
9. "Why would cities partner with you?"
10. "What's your go-to-market strategy?"

PRODUCT:
11. "What makes this different from Google Maps parking?"
12. "How do you prevent fake reports?"
13. "What if someone reports wrong information?"
14. "Can this work for garage parking too?"

For each question, provide:
- Concise answer (30-45 seconds)
- Key talking points
- Data/examples to reference
- How to pivot back to your strengths

```

---

## IX. CODE GENERATION PROMPTS

**Prompt 29: TypeScript Type Definitions**

```
Generate TypeScript types for parking app:

ENTITIES:
1. Spot
2. Report
3. User
4. Zone
5. ConfidenceScore
6. Location (lat/lon)
7. API Request/Response types

REQUIREMENTS:
- Strict typing (no 'any')
- Proper enum usage
- Optional vs required fields
- Timestamp handling (Date vs string)
- Geospatial types (latitude, longitude validation)
- API response wrappers (success/error)

ORGANIZATION:
- Separate files: types/spot.ts, types/report.ts, etc.
- Shared types in types/common.ts
- Export all from types/index.ts

Include JSDoc comments explaining each type

```

**Prompt 30: Environment Variable Manager**

```
Create environment variable setup with validation:

VARIABLES NEEDED:
- DATABASE_URL (PostgreSQL connection string)
- PORT (server port, default 3000)
- NODE_ENV (development|staging|production)
- MAPBOX_API_KEY (map service)
- JWT_SECRET (authentication)
- REDIS_URL (optional caching)
- SENTRY_DSN (optional error tracking)

FEATURES:
1. Load from .env file (use dotenv)
2. Validate all required variables on startup
3. Type-safe access (no process.env.X everywhere)
4. Default values where appropriate
5. Error messages for missing/invalid vars
6. Different configs for dev/staging/prod

Provide:
- .env.example file
- config.ts with validation
- Usage examples

```

---

## X. DEBUGGING & OPTIMIZATION PROMPTS

**Prompt 31: Performance Analysis**

```
Analyze and optimize this geospatial query for performance:

CURRENT QUERY:
[paste your slow query here]

DATABASE: PostgreSQL with PostGIS
TABLE SIZE: ~100,000 spots
QUERY FREQUENCY: ~50 requests/second
CURRENT PERFORMANCE: 800ms average

REQUESTED ANALYSIS:
1. Explain query plan (EXPLAIN ANALYZE)
2. Identify bottlenecks
3. Suggest index improvements
4. Propose query rewrite if needed
5. Caching strategy recommendations
6. Expected performance improvement

Include before/after benchmarks and migration script for index changes

```

**Prompt 32: Memory Leak Detector**

```
Review this WebSocket server code for potential memory leaks:

[paste your socket.io server code]

CHECK FOR:
1. Event listeners not cleaned up
2. Growing arrays/objects without bounds
3. Timers/intervals not cleared
4. Database connections not closed
5. Circular references
6. Large objects kept in closure scope

PROVIDE:
- Line-by-line analysis
- Specific leak risks with severity
- Fixed code with cleanup logic
- Best practices for resource management
- Monitoring recommendations (heap snapshots, etc.)

```

**Prompt 33: Security Audit**

```
Perform security audit on parking app API:

REVIEW AREAS:
1. Input validation (SQL injection, XSS)
2. Authentication/Authorization
3. Rate limiting effectiveness
4. CORS configuration
5. Sensitive data exposure (logs, errors)
6. Dependency vulnerabilities
7. API key protection
8. Location data privacy

FOR EACH ISSUE:
- Severity (Critical/High/Medium/Low)
- Attack vector example
- Remediation steps
- Code example of fix

Run npm audit and suggest dependency updates

```

---

## XI. ADVANCED FEATURE PROMPTS

**Prompt 34: Predictive ML Model**

```
Design machine learning model to predict parking availability:

GOAL: Predict probability of finding parking at location X at time Y

FEATURES (input):
- Location (lat, lon)
- Hour of day (0-23)
- Day of week (0-6)
- Weather (sunny, rain, snow)
- Nearby events (binary: event within 500m)
- Historical occupancy average
- Recent trend (occupancy increasing/decreasing)

TARGET (output):
- Probability of availability (0-1)

MODEL OPTIONS:
- Logistic Regression (baseline)
- Random Forest
- XGBoost
- Neural Network (if sufficient data)

TRAINING DATA:
- Use historical reports table
- Aggregate by location grid + time windows
- Feature engineering suggestions

EVALUATION:
- Train/test split
- Cross-validation strategy
- Metrics: AUC-ROC, precision, recall
- Acceptable threshold for "high confidence" prediction

Provide Python code for model training and inference API endpoint

```

**Prompt 35: Notification System**

```
Design push notification system for parking app:

NOTIFICATION TYPES:
1. "Spot available nearby" (real-time, location-based)
2. "Your parked location saved" (confirmation)
3. "Someone corrected your report" (feedback)
4. "You earned a badge!" (gamification)
5. "Parking restrictions starting soon" (street cleaning alert)

IMPLEMENTATION:
- Use Firebase Cloud Messaging (FCM) for cross-platform
- Background location-based triggers
- User preferences (opt-in/opt-out per type)
- Quiet hours (no notifications 10pm-7am)
- Smart batching (don't spam)

ARCHITECTURE:
- Queue system for notifications (Bull.js or AWS SQS)
- Targeting logic (who gets which notification)
- Delivery tracking and analytics
- A/B testing framework for notification text

Provide:
- Backend notification service
- Frontend FCM integration
- User preference management
- Example notification payloads

```

---

## XII. META PROMPTS (Prompts About Prompting)

**Prompt 36: Code Review Assistant**

```
You are an expert code reviewer for a hackathon parking app project. When I paste code, analyze it for:

1. FUNCTIONALITY: Does it work correctly? Edge cases handled?
2. READABILITY: Clear variable names, comments where needed?
3. PERFORMANCE: Any obvious bottlenecks or inefficiencies?
4. SECURITY: Input validation, error handling, data exposure?
5. BEST PRACTICES: Following conventions for [language/framework]?
6. HACKATHON CONTEXT: Is this good enough for demo, or overengineered?

Prioritize issues by severity and provide specific fix suggestions with code examples. Remember: hackathon code doesn't need to be perfect, but should work reliably for the demo.

[Then paste your code]

```

**Prompt 37: Explain Like I'm Five (ELI5)**

```
I'm about to present my parking app to hackathon judges who may not be deeply technical. Explain this concept in simple terms that anyone can understand:

[paste technical concept: e.g., "time-decaying confidence scores with geospatial aggregation"]

REQUIREMENTS:
- No jargon
- Use analogies or metaphors
- Maximum 2-3 sentences
- Could explain to grandparent or 10-year-old
- Emphasize practical benefit, not technical details

This will help me explain my innovation clearly during the presentation.

```

**Prompt 38: Feature Prioritizer**

```
I have limited time (X hours remaining) in my hackathon. Help me prioritize these features:

REMAINING FEATURES:
[list your planned features]

CURRENT STATUS:
- Core functionality: [working/not working]
- Time remaining: [X hours]
- Team capacity: [4 people]

FOR EACH FEATURE, RATE:
1. Demo impact (1-10): How impressive for judges?
2. Implementation time (hours)
3. Technical risk (Low/Medium/High)
4. Dependencies (what must work first)

PROVIDE:
- Ranked priority list (must-have â nice-to-have)
- Suggested allocation of remaining time
- Features to cut if time runs short
- "Demo-ready" minimum viable state for each feature

```

---

## XIII. QUICK REFERENCE: BEST PROMPTING PRACTICES

### Effective Prompt Structure

**1. Context First**

```
I'm building [what] for [purpose] using [tech stack].
Currently at [stage of development].
Team has [skills/constraints].

```

**2. Specific Requirements**

```
MUST HAVE:
- [requirement 1]
- [requirement 2]

SHOULD HAVE:
- [nice-to-have 1]

CONSTRAINTS:
- [limitation 1]
- [time/resource constraint]

```

**3. Desired Output Format**

```
OUTPUT:
- [Code/Explanation/Diagram]
- [With specific elements]
- [In specific format]

INCLUDE:
- Comments explaining key decisions
- Error handling
- Example usage

```

### Improving Prompt Results

**If Output Is Too Generic:**
Add: "Make this specific to a parking availability app with real-time updates and confidence scoring"

**If Output Is Too Complex:**
Add: "Keep it simple for a 24-hour hackathon. Prioritize working over perfect."

**If Output Misses Key Point:**
Add: "Focus especially on [key aspect]. This is the innovation that judges will care about."

**If You Need Alternatives:**
Add: "Provide 2-3 different approaches with pros/cons for each. Consider [constraint]."

---

## XIV. HACKATHON-SPECIFIC PROMPT TEMPLATES

**Template 1: "I'm Stuck"**

```
I'm stuck on [specific problem] in my hackathon project.

WHAT I'VE TRIED:
- [attempt 1] - resulted in [error/issue]
- [attempt 2] - resulted in [error/issue]

CURRENT CODE:
[paste relevant code]

ERROR MESSAGE:
[paste error if applicable]

CONSTRAINTS:
- Limited time remaining ([X] hours)
- Need this working for demo at [time]
- Can't change [existing component] due to dependencies

Help me debug this or suggest a simpler alternative approach that will work for the demo.

```

**Template 2: "Make It Demo-Ready"**

```
I have this working feature but it's not polished enough for demo:

[describe current state]

ISSUES:
- [problem 1: e.g., UI is ugly]
- [problem 2: e.g., no error handling]
- [problem 3: e.g., slow performance]

TIME AVAILABLE: [X] hours
PRIORITY: Looking good > perfect functionality

Suggest quick improvements that have maximum visual impact with minimum time investment. What's the "MVP polish" I should focus on?

```

**Template 3: "Last-Minute Pivot"**

```
We need to pivot due to [technical blocker/time constraint].

ORIGINAL PLAN: [what you were building]
BLOCKER: [why it's not working]
TIME LEFT: [X] hours

ASSETS WE HAVE:
- [working component 1]
- [working component 2]
- [data/resources available]

Suggest a pivot strategy that:
1. Salvages existing work
2. Is achievable in remaining time
3. Still demonstrates core innovation
4. Makes sense in our pitch narrative

Provide step-by-step plan for remaining hours.

```

---

## XV. PROMPT LIBRARY ORGANIZATION

### Save These Prompts As:

**In Your Project:**

```
/prompts
  /design
    - ui-design.md
    - icons.md
    - user-flows.md
  /frontend
    - components.md
    - hooks.md
    - websocket.md
  /backend
    - api.md
    - database.md
    - algorithms.md
  /testing
    - unit-tests.md
    - integration-tests.md
  /docs
    - readme.md
    - api-docs.md
  /meta
    - debugging.md
    - code-review.md

```

### Usage During Hackathon

**Hour 0-2:** Use setup/foundation prompts
**Hour 2-12:** Use feature development prompts
**Hour 12-18:** Use integration/testing prompts
**Hour 18-22:** Use polish/optimization prompts
**Hour 22-24:** Use documentation/presentation prompts

---

**REMEMBER:** AI is a tool, not a crutch. Use prompts to:

- â Accelerate routine coding
- â Generate boilerplate
- â Debug faster
- â Learn new patterns
- â Don't blindly copy without understanding
- â Don't skip testing AI-generated code
- â Don't let AI make architectural decisions without team input

---

**Good luck with your hackathon! Use these prompts strategically to maximize your team's output and win! ð**